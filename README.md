# ptolemy

My reading list. Mostly old papers and books, in no particular order.
I am forgetful, so I need this. This reading history starts on the
brink of 2017, so any interesting things I have encountered before that
point in my life will not be included.

Named after Ptolemy I Soter, who built the Library of Alexandria.

## To Do

### Computer Science

#### Papers
* [Sketchpad - A Man-Machine Graphical Communication System](https://www.cs.purdue.edu/homes/hosking/197/canon/sutherland.pdf) by **Ivan Sutherland** (1964)
* [A Programming Language for Mechanical Translation](http://www.mt-archive.info/MT-1958-Yngve.pdf) by **Victor Yngve** (1958)
* [Do Be Do Be Do](https://arxiv.org/pdf/1611.09259v1.pdf) by **Sam Lindley et al.** (2016)
* [From Interpretation to Compilation](ftp://ftp.cs.ru.nl/pub/Clean/papers/2008/janj08-CEFP07-InterpretationToCompilation.pdf) by **Jan Jansen et al.** (2008)
* [PLANNER: A Language for Manipulating Models and Proving Theorems in a Robot](https://dspace.mit.edu/bitstream/handle/1721.1/6171/AIM-168.pdf?sequence=2) by **Carl Hewitt** (1970)
* [Abstracting Definitional Interpreters](https://github.com/write-you-a-scheme-v2/scheme/blob/master/sources/AbstractDefinitionalInterpreters.pdf) by **David Darais et al.** (2016?)
* [Scalable Garbage Collection via Remembered Set Summarization and Refinement](http://www.cesura17.net/~will/Professional/Research/Papers/Klock/klock11-diss.pdf) by **Felix S. Klock II** (2011)
* *Lambda, the ultimate label or a simple optimizing compiler for Scheme* by **William Clinger and Thomas Hansen** (1994)
* *Linear combinations of radioactive decay models for generational garbage collection* by **William Clinger and Fabio Rojas** (2006)
* [Generalized Parser Combinators](http://www.cs.uwm.edu/%7Edspiewak/papers/generalized-parser-combinators.pdf) by **Daniel Spiewak** (2010)
* [Correct and Efficient Work-Stealing for Weak Memory Models](http://www.di.ens.fr/~zappa/readings/ppopp13.pdf) by **Nhat Minh Le et al.** (2013)
* [Hygienic Macro Expansion](http://web.cs.ucdavis.edu/%7Edevanbu/teaching/260/kohlbecker.pdf) by **Eugene Kohlbecker et al.** (1986)
* [Automatic Error Elimination by Horizontal Code Transfer across Multiple Applications](http://people.csail.mit.edu/stelios/papers/codephage_pldi15.pdf) by **Stelios Sidiroglou-Douskos et al.** (2015)
* [An optimistic approach to lock-free FIFO queues](http://people.csail.mit.edu/edya/publications/OptimisticFIFOQueue-journal.pdf) by **Edya Ladan-Mozes and Nir Shavit** (2004)
* [A Practical Minimal Perfect Hashing Method](http://homepages.dcc.ufmg.br/~nivio/papers/wea05.pdf) by **Fabiano Botelho et al.**
* [Scalable Synchronous Queues](http://www.cs.rochester.edu/u/scott/papers/2009_Scherer_CACM_SSQ.pdf) by **William Scherer III et al.** (2009)
* [Mirrors: Design Principles for Meta-level Facilities of Object-Oriented Programming Languages](http://bracha.org/mirrors.pdf) by **Gilad Bracha and David Ungar** (2004)
* [Nonblocking Concurrent Data Structures with Condition Synchronization](https://web.archive.org/web/20110206165336/http://www.cs.rice.edu/~wns1/papers/2004-DISC-DDS.pdf) by **William Scherer III et al.** (2004)
* [Simple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue Algorithms](http://www.cs.rochester.edu/~scott/papers/1996_PODC_queues.pdf) by **Maged Michael and Michael Scott** (1996)
* [Generational Garbage Collection and the Radioactive Decay Model](http://www.cesura17.net/~will/Professional/Research/Papers/radioactive.pdf) by **William Clinger** (1997)
* [Algebra of Parameterised Graph](https://www.staff.ncl.ac.uk/andrey.mokhov/algebra.pdf) by **Andrey Mokhov and Victor Khomeko** (2014)
* [A Fast Procedure for Computing the Distance Between Complex Objects in Thee-Dimensional Space](https://graphics.stanford.edu/courses/cs448b-00-winter/papers/gilbert.pdf) by **Elmer Gilbert et al.** (1988)
* [Type Systems as Macros](http://www.ccs.neu.edu/home/stchang/pubs/ckg-popl2017.pdf) by **Stephen Chang et al.** (2017)
* [Scalable Garbage Collection with Guaranteed MMU](http://www.cesura17.net/~will/Professional/Research/Papers/gfremsets.pdf) by **William Clienger and Felix Klock II** (2009)
* [What You Always Wanted to Know About Datalog (And Never Dared to Ask)](http://www.csd.uoc.gr/%7Ehy562/1112_spring/instr_material/WhatYouAlwaysWantedtoKnowAboutDatalog_AndNeverDaredtoAsk.pdf) by **Stefano Ceri et al.** (1989)

#### Books
* *Gödel, Escher, Bach* by **Douglas Hofstaedter** (1979)
* *Computation - Finite and Infinite Machines* by **Marvin Minsky** (1967)
* *The Sciences of the Artificial* by **Herbert Simon** (1969)
* [The Implementation of Functional Programming Languages](http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/start.htm) by **Simon Peyton Jones** (1987)
* [How to Design Programs](http://htdp.org/2003-09-26/Book/curriculum.html) by **Matthias Felleisen et al.** (2001)
* [Preliminary Proceedings of the Ninth Workshop on Language Descriptions Tools and Applications LDTA 2009](http://ldta.info/2009/ldta2009proceedings.pdf) by **Torbjörn Ekman and Jurgen Vinju** (2009)
* [Distributed Algorithms](http://users.ics.aalto.fi/suomela/da/) by **Jukka Suomela** (2014)

### Recreational

#### Papers
* [The Psychological Impact Of Incarceration: Implications for Post-Prison Adjustment](http://www.urban.org/sites/default/files/alfresco/publication-pdfs/410624-The-Psychological-Impact-of-Incarceration.PDF) by **Craig Hainey** (2002)

#### Books
* *A History of Eternity* by **Jorge Luis Borges** (1936)
* *The Garden of the Forking Paths* by **Jose Luis Borges** (1941)
* *A Thousand Plateaus* by **Gilles Deleuze and Felix Guattari** (1980)
* *Archeology of Violence* by **Pierre Clastres** (1980)
* *Geometric Galois Actions* by **Leila Schneps and Pierre Lochak** (1997)
* *The Order of Things* by **Michel Foucault** (1966)
* *Do Androids Dream of Electric Sheep?* by **Philip K. Dick** (1968)

## Done

First off, a caveat. I am most certainly not qualified to judge any of
the writings I judge, so please see everything I am writing as notes to
myself to remind me of key ideas in the paper or book at hand and what
I thought of them. They are as biased and right and wrong about things
as I personally am. So if you do not trust me as a person, do not trust
my write-ups.

### Computer Science

#### Papers
* [Growing a Proof Assistant](https://williamjbowman.com/resources/cur.pdf) by **William Bowman** (2016)

I am hesitant to write anything about this paper at all, as it is a draft
and subject to change. I will, however, write down a few things that came
to my mind when I first read the paper. Maybe I will reread it when it is
done.

The paper presents a racket lang implementing a proof assistant. The key
idea is to make proof assistants easier to extend and work with apart
from writing proof. Maybe I am missing something obvious, but for me
most of the features presented before chapter 5 are not actually features
of the lang at hand but of Racket itself. After a long-winded motivation,
we finally arrive at the notion of tactics in Cur - the language at hand -,
which are interesting and definitely worth the read. My major problem with
the language is that it sacrifices a convenient syntax to write proofs - the
sweetexps are not really helping much - to make it easier to integrate into
Racket. The proof system looks a little clumsy to me, but we gain extensibility
for it. If that scratches an itch, it might be useful, but I really think
the syntax does not help to make the proofs themselves readable.

* [Parsing With Derivatives - A Functional Pearl](http://matt.might.net/papers/might2011derivatives.pdf) by **Matthew Might et al.** (2011)

Beautiful little pearl on how to make Brzozowski derivatives usable
for real-world parsing through performance tweaks (memoization, fixpoints,
laziness). Uses Racket code (which helped me a lot with understanding
some of the underlying equations).

* [Simply Easy! An Implemenetation of a Dependently Typed Lambda Calculus](http://strictlypositive.org/Easy.pdf) by **Andres Löh et al.** (2007)

Interesting implementation of a dependently typed lambda calculus.
The paper is worth reading for the description of current Haskell
programs alone: "a ghastly hodgepodge of generalized algebraic data
types, multi-parameter type classes with functional dependencies,
impredicative higher-ranked types, and even data kinds." Some of
the figures completely puzzled me (e.g. figure 10 on the type
rules in the language that is being laid out), but I am used to
that in type system papers. The rules are usually explained in
the text anyway, so I just skim the figures.

The main contribution of this paper for me is not that it shows
dependent types are possible to implement (anyone who has heard
of Agda, Coq, or Idris will know that by now), but that it can
even be straightforward. The implementation given in the paper
is mind-boggingly simple, and I think that is pretty amazing.

* [Situations, Actions, and Causal Laws](http://www.dtic.mil/dtic/tr/fulltext/u2/785031.pdf) by **John McCarthy** (1963)

Another one of these classic papers that I had missed. I don't
think I completely understand the paper, although, as per usual
McCarthy does not fail to instill a lot of thoughts in my slow
mind. His idea of the Advice Taker is an interesting forgotten
concept (probably due to the AI winter, though I am not around
long enough to really judge that).

His relational approach to the computational view of reality
reminds me a lot of Prolog, obviously, although I am unsure
how much Prolog was really influenced by the Advice Taker (I
should probably read more about that as well).

* [Reflections on Trusting Trust](http://www3.cs.stonybrook.edu/%7Ecse509/p761-thompson.pdf) by **Ken Thompson** (1984)

While I do not fully agree with the moral view of the world
presented in this talk, I think the idea of a malicious compiler
is cute. It has not occurred to me yet but is obvious when
you think about it - a trademark of interesting ideas.

* [Out of the Tar Pit](http://shaffner.us/cs/papers/tarpit.pdf) by **Ben Moseley and Peter Marks** (? > 2003)

The essential paper on FRP. Apart from giving an excellent
introduction into what FRP is and should be, the authors
also spend a great deal of time on explaining how different
programming paradigms deal with state and complexity and
their individual shortcomings (that were supposedly overcome
through FRP).

Great paper, very long, but - at least in my opinion - out
of necessity, not borne from babbling.

* [Rapid Case Dispatch in Scheme](http://scheme2006.cs.uchicago.edu/07-clinger.pdf) by **William Clinger** (2006)

An inside view into how Larceny does optimizations of `case`.
Interesting if a bit complex and hard to read if one is unfamiliar
with reading intermediate form Larceny programs. The examples
are rather simple, though. I think the mixing of strategies
to achieve maximum performance sounds like a hard optimization
to get right but worth its while.

## Recreational

### Papers
* [A Study of Prisoners and Guards in a Simulated Prison](http://www.zimbardo.com/downloads/1973%20A%20Study%20of%20Prisoners%20and%20Guards,%20Naval%20Research%20Reviews.pdf) by **Philip Zimbardo et al.** (1973)

One of the mose famous papers of psychology. I had to read one
of Zimabrdo's books when studying psychology at University, but
never got around to actually reading this infamous paper. It is
both well-written and topically interesting, but extremely disturbing.
I doubt any ethics committee would let an experiment like that
happen these days.
