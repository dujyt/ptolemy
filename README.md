# ptolemy

My reading list. Mostly papers and books, in no particular order.
I am forgetful, so I need this. This reading history starts on the
brink of 2017, so any interesting things I have encountered before that
point in my life will not be included.

Some of the papers and books do not have links included, because they
might be protected by paywalls or other DRM, because it seems we have to
pay for progress. You might find these papers online anyway,
[SciHub](sci-hub.io) is a great resource; it might be illegal in your
country to use this site, though.

Named after Ptolemy I Soter, who built the Library of Alexandria.

## To Do

### Computer Science

#### Papers
* [A Programming Language for Mechanical Translation](http://www.mt-archive.info/MT-1958-Yngve.pdf) by **Victor Yngve** (1958)
* [From Interpretation to Compilation](ftp://ftp.cs.ru.nl/pub/Clean/papers/2008/janj08-CEFP07-InterpretationToCompilation.pdf) by **Jan Jansen et al.** (2008)
* [PLANNER: A Language for Manipulating Models and Proving Theorems in a Robot](https://dspace.mit.edu/bitstream/handle/1721.1/6171/AIM-168.pdf?sequence=2) by **Carl Hewitt** (1970)
* [Abstracting Definitional Interpreters](https://github.com/write-you-a-scheme-v2/scheme/blob/master/sources/AbstractDefinitionalInterpreters.pdf) by **David Darais et al.** (2016?)
* [Scalable Garbage Collection via Remembered Set Summarization and Refinement](http://www.cesura17.net/~will/Professional/Research/Papers/Klock/klock11-diss.pdf) by **Felix S. Klock II** (2011)
* *Lambda, the ultimate label or a simple optimizing compiler for Scheme* by **William Clinger and Thomas Hansen** (1994)
* *Linear combinations of radioactive decay models for generational garbage collection* by **William Clinger and Fabio Rojas** (2006)
* [Correct and Efficient Work-Stealing for Weak Memory Models](http://www.di.ens.fr/~zappa/readings/ppopp13.pdf) by **Nhat Minh Le et al.** (2013)
* [Automatic Error Elimination by Horizontal Code Transfer across Multiple Applications](http://people.csail.mit.edu/stelios/papers/codephage_pldi15.pdf) by **Stelios Sidiroglou-Douskos et al.** (2015)
* [An optimistic approach to lock-free FIFO queues](http://people.csail.mit.edu/edya/publications/OptimisticFIFOQueue-journal.pdf) by **Edya Ladan-Mozes and Nir Shavit** (2004)
* [A Practical Minimal Perfect Hashing Method](http://homepages.dcc.ufmg.br/~nivio/papers/wea05.pdf) by **Fabiano Botelho et al.**
* [Scalable Synchronous Queues](http://www.cs.rochester.edu/u/scott/papers/2009_Scherer_CACM_SSQ.pdf) by **William Scherer III et al.** (2009)
* [Mirrors: Design Principles for Meta-level Facilities of Object-Oriented Programming Languages](http://bracha.org/mirrors.pdf) by **Gilad Bracha and David Ungar** (2004)
* [Nonblocking Concurrent Data Structures with Condition Synchronization](https://web.archive.org/web/20110206165336/http://www.cs.rice.edu/~wns1/papers/2004-DISC-DDS.pdf) by **William Scherer III et al.** (2004)
* [Simple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue Algorithms](http://www.cs.rochester.edu/~scott/papers/1996_PODC_queues.pdf) by **Maged Michael and Michael Scott** (1996)
* [Algebra of Parameterised Graph](https://www.staff.ncl.ac.uk/andrey.mokhov/algebra.pdf) by **Andrey Mokhov and Victor Khomeko** (2014)
* [A Fast Procedure for Computing the Distance Between Complex Objects in Thee-Dimensional Space](https://graphics.stanford.edu/courses/cs448b-00-winter/papers/gilbert.pdf) by **Elmer Gilbert et al.** (1988)
* [Scalable Garbage Collection with Guaranteed MMU](http://www.cesura17.net/~will/Professional/Research/Papers/gfremsets.pdf) by **William Clienger and Felix Klock II** (2009)
* [What You Always Wanted to Know About Datalog (And Never Dared to Ask)](http://www.csd.uoc.gr/%7Ehy562/1112_spring/instr_material/WhatYouAlwaysWantedtoKnowAboutDatalog_AndNeverDaredtoAsk.pdf) by **Stefano Ceri et al.** (1989)
* [Scheduling Parallel Programs by Work Stealing with Private Deques](http://www.chargueraud.org/research/2013/ppopp/full.pdf) by **Umur Acar** (2013)
* [A Correspondence Between ALGOL 60 and Church's Lambda-Notation: Part I](http://fi.ort.edu.uy/innovaportal/file/20124/1/22-landin_correspondence-between-algol-60-and-churchs-lambda-notation.pdf) by **P. Landin** (1965)
* [Harnessing the Multicores: Nested Data Parallelism in Haskell](http://wiki.epfl.ch/edicpublic/documents/Candidacy%20exam/papers-ndph.pdf) by **Simon Peyton Jones et al.** (2008)
* [Older-first garbage collection in practice](http://www.ccs.neu.edu/home/lth/thesis/index.html) by **Lars Hansen** (2000)
* [A Unified Theory of Garbage Collection](http://www.cs.virginia.edu/~cs415/reading/bacon-garbage.pdf) by **David Bacon et al.** (2004)
* [Opportunities and Challenges for Data Center Demand Response](http://smart.caltech.edu/papers/dcdrsurvey.pdf) by **Adam Wierman et al.** (2014)
* [Branch Flow Model: Relaxations and Convexification—Part I](http://smart.caltech.edu/papers/relaxconvex2parts.pdf) by **Masoud Farivar and Steven Low** (2013)
* [The Art of the Interpreter or, the Modularity Complex (Parts Zero, One, and Two)](http://repository.readscheme.org/ftp/papers/ai-lab-pubs/AIM-453.pdf) by **Guy Steele and Gerald Sussman** (1978)
* [Design of LISP-based Processors, or SCHEME: A Dielectric LISP, or Finite Memories Considered Harmful, or LAMBDA: The Ultimate Opcode](http://repository.readscheme.org/ftp/papers/ai-lab-pubs/AIM-514.pdf) by **Guy Steele and Gerald Sussman** (1979)
* [An Open Framework for the Reproducible Study of the Iterated Prisoner’s Dilemma](http://openresearchsoftware.metajnl.com/articles/10.5334/jors.125/) by **Vincent Knight et al.** (2016)
* [“Major key alert!” - Anomalous keys in Tor relay](https://nymity.ch/anomalous-tor-keys/pdf/anomalous-tor-keys.pdf) by **George Kadianakis et al.** (2017)

#### Books
* *Gödel, Escher, Bach* by **Douglas Hofstaedter** (1979)
* *Computation - Finite and Infinite Machines* by **Marvin Minsky** (1967)
* *The Sciences of the Artificial* by **Herbert Simon** (1969)
* [The Implementation of Functional Programming Languages](http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/start.htm) by **Simon Peyton Jones** (1987)
* [How to Design Programs](http://htdp.org/2003-09-26/Book/curriculum.html) by **Matthias Felleisen et al.** (2001)
* [Preliminary Proceedings of the Ninth Workshop on Language Descriptions Tools and Applications LDTA 2009](http://ldta.info/2009/ldta2009proceedings.pdf) by **Torbjörn Ekman and Jurgen Vinju** (2009)
* [Distributed Algorithms](http://users.ics.aalto.fi/suomela/da/) by **Jukka Suomela** (2014)
* [Sequent Calculus as a Compiler Intermediate Language](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/04/sequent-calculus-icfp16.pdf) by **Simon Peyton Jones et al.** (2016)
* [RABBIT: A Compiler for SCHEME](http://repository.readscheme.org/ftp/papers/ai-lab-pubs/AITR-474.pdf) by **Guy Steele** (1978)
* *The Psychology of Computer Programming* by **Gerald Weinber** (1971)

### Recreational

#### Papers
* [The Psychological Impact Of Incarceration: Implications for Post-Prison Adjustment](http://www.urban.org/sites/default/files/alfresco/publication-pdfs/410624-The-Psychological-Impact-of-Incarceration.PDF) by **Craig Hainey** (2002)
* [Holy Stigmata, Anorexia, and Self-Mutilation: Parallels in Pain and Imagining](http://www.academia.edu/541052/Holy_Stigmata_Anorexia_and_Self-Mutilation_Parallels_in_Pain_and_Imagining) by **Robert Mullen** (2010)

#### Books
* *A History of Eternity* by **Jorge Luis Borges** (1936)
* *The Garden of the Forking Paths* by **Jose Luis Borges** (1941)
* *A Thousand Plateaus* by **Gilles Deleuze and Felix Guattari** (1980)
* *Archeology of Violence* by **Pierre Clastres** (1980)
* *Geometric Galois Actions* by **Leila Schneps and Pierre Lochak** (1997)
* *The Order of Things* by **Michel Foucault** (1966)
* *Do Androids Dream of Electric Sheep?* by **Philip K. Dick** (1968)
* [Dialogues Concerning Natural Religion](http://www.davidhume.org/texts/dnr.html) by **David Hume** (1779)

## Done

First off, a caveat. I am most certainly not qualified to judge any of
the writings I judge, so please see everything I am writing as notes to
myself to remind me of key ideas in the paper or book at hand and what
I thought of them. They are as biased and right and wrong about things
as I personally am. So if you do not trust me as a person, do not trust
my write-ups.

### Computer Science

#### Papers
* [Growing a Proof Assistant](https://williamjbowman.com/resources/cur.pdf) by **William Bowman** (2016)

I am hesitant to write anything about this paper at all, as it is a draft
and subject to change. I will, however, write down a few things that came
to my mind when I first read the paper. Maybe I will reread it when it is
done.

The paper presents a racket lang implementing a proof assistant. The key
idea is to make proof assistants easier to extend and work with apart
from writing proof. Maybe I am missing something obvious, but for me
most of the features presented before chapter 5 are not actually features
of the lang at hand but of Racket itself. After a long-winded motivation,
we finally arrive at the notion of tactics in Cur - the language at hand -,
which are interesting and definitely worth the read. My major problem with
the language is that it sacrifices a convenient syntax to write proofs - the
sweetexps are not really helping much - to make it easier to integrate into
Racket. The proof system looks a little clumsy to me, but we gain extensibility
for it. If that scratches an itch, it might be useful, but I really think
the syntax does not help to make the proofs themselves readable.

* [Parsing With Derivatives - A Functional Pearl](http://matt.might.net/papers/might2011derivatives.pdf) by **Matthew Might et al.** (2011)

Beautiful little pearl on how to make Brzozowski derivatives usable
for real-world parsing through performance tweaks (memoization, fixpoints,
laziness). Uses Racket code (which helped me a lot with understanding
some of the underlying equations).

* [Simply Easy! An Implemenetation of a Dependently Typed Lambda Calculus](http://strictlypositive.org/Easy.pdf) by **Andres Löh et al.** (2007)

Interesting implementation of a dependently typed lambda calculus.
The paper is worth reading for the description of current Haskell
programs alone: "a ghastly hodgepodge of generalized algebraic data
types, multi-parameter type classes with functional dependencies,
impredicative higher-ranked types, and even data kinds." Some of
the figures completely puzzled me (e.g. figure 10 on the type
rules in the language that is being laid out), but I am used to
that in type system papers. The rules are usually explained in
the text anyway, so I just skim the figures.

The main contribution of this paper for me is not that it shows
dependent types are possible to implement (anyone who has heard
of Agda, Coq, or Idris will know that by now), but that it can
even be straightforward. The implementation given in the paper
is mind-boggingly simple, and I think that is pretty amazing.

* [Situations, Actions, and Causal Laws](http://www.dtic.mil/dtic/tr/fulltext/u2/785031.pdf) by **John McCarthy** (1963)

Another one of these classic papers that I had missed. I don't
think I completely understand the paper, although, as per usual
McCarthy does not fail to instill a lot of thoughts in my slow
mind. His idea of the Advice Taker is an interesting forgotten
concept (probably due to the AI winter, though I am not around
long enough to really judge that).

His relational approach to the computational view of reality
reminds me a lot of Prolog, obviously, although I am unsure
how much Prolog was really influenced by the Advice Taker (I
should probably read more about that as well).

* [Reflections on Trusting Trust](http://www3.cs.stonybrook.edu/%7Ecse509/p761-thompson.pdf) by **Ken Thompson** (1984)

While I do not fully agree with the moral view of the world
presented in this talk, I think the idea of a malicious compiler
is cute. It has not occurred to me yet but is obvious when
you think about it - a trademark of interesting ideas.

* [Out of the Tar Pit](http://shaffner.us/cs/papers/tarpit.pdf) by **Ben Moseley and Peter Marks** (2006)

The essential paper on FRP. Apart from giving an excellent
introduction into what FRP is and should be, the authors
also spend a great deal of time on explaining how different
programming paradigms deal with state and complexity and
their individual shortcomings (that were supposedly overcome
through FRP).

Great paper, very long, but - at least in my opinion - out
of necessity, not borne from babbling.

* [Type Systems as Macros](http://www.ccs.neu.edu/home/stchang/pubs/ckg-popl2017.pdf) by **Stephen Chang et al.** (2017)

A bit hard to read and involved, but very deep insights.
I might try to recreate in zepto.

The syntax of all of the languages and systems presented
were ugly. That's not that big of a problem, though, if
one puts a bit more abstraction around them they could
actually be pleasant to work with.

* [Rapid Case Dispatch in Scheme](http://scheme2006.cs.uchicago.edu/07-clinger.pdf) by **William Clinger** (2006)

An inside view into how Larceny does optimizations of `case`.
Interesting if a bit complex and hard to read if one is unfamiliar
with reading intermediate form Larceny programs. The examples
are rather simple, though. I think the mixing of strategies
to achieve maximum performance sounds like a hard optimization
to get right but worth its while.

* [Do Be Do Be Do](https://arxiv.org/pdf/1611.09259v1.pdf) by **Sam Lindley et al.** (2016)

Frank is certainly an interesting language. I am not quite
sure I understand all of its semantics and implications, though.
Especially the explanation of Core Frank left me not quite satisfied,
but that might just be me and my personal problems with the notation
again. Might have to give that one another read if I want to go deeper
into effects languages.

* [Sketchpad - A Man-Machine Graphical Communication System](https://www.cs.purdue.edu/homes/hosking/197/canon/sutherland.pdf) by **Ivan Sutherland** (1964)

This is one of the most humbling papers I have ever read. The complexity
of the system described—Sketchpad—is mind-boggling, considering the tooling
of the time. I marvel at it in the same way we marvel at things of complexity
that have been built by generations that had to do without the conveniences
and abstractions that we now have. I did not take away a lot in the hard
technical sense, and yet it influenced my thinking greatly already.

* [Hygienic Macro Expansion](http://web.cs.ucdavis.edu/%7Edevanbu/teaching/260/kohlbecker.pdf) by **Eugene Kohlbecker et al.** (1986)

The fundamental paper on hygienic macro expansion. Reads fairly nicely.
I was familiar with the concept before reading the paper, but it really
feels like my basic grasp on the concept is much stronger now. Very
helpful for the system (System Z) I am currently working on, as I will
have to implement it in a language that is not Scheme or even a Lisp there
and that is a fairly badly documented process I find.

* [A prettier printer](http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf) by **Philip Wadler** (1997)

Philip Wadler is my spirit animal. In this paper he essentially conjures
up a wonderfully simple and composable algebra of printing and uses it
to implement a simple, efficient, and readable pretty printer. It makes
me want to implement one of my own. Then again, why would I if I cannot
even begin to capture the beauty of this paper? Very readable and very
pretty indeed.

* [Flattening Combinators: Surviving Without Parentheses](http://www.westpoint.edu/eecs/SiteAssets/SitePages/Faculty%20Publication%20Documents/Okasaki/jfp03flat.pdf) by **Chris Okasaki** (2003)

A theoretical pearl by Chris Okasaki (of "Functional Datastructures" fame).
It shows how to rewrite arbitrary combinators to stack expressions, similar
to what you would to in reverse polish notation. It's a simple yet very beautiful
showcase of how to rewrite postifx notation to combinators and vice versa
and invents an interesting approach to Gödel numbering on the way, in less
than eight pages. The latter of the two implications is a bit harder to digest,
and less applicable to what I am doing, but relatively obvious, which astounded
me considering I am not a very battle-hardened theoretical computer scientist.
Maybe my reading just starts to bear fruits or maybe it is Okasaki's pristine
writing.

* [Why New Programming Languages for Simulation?](http://people.csail.mit.edu/fred/why.pdf) by **Gilbert Louis Bernstein and Fredrik Kjolstad** (2016)

Coming from the language designers of Ebb and Simit, respectively, this nice
little summary on why to create new languages is very centered around simulation,
but can be easily generalized. It tries to tackle the age-old question of "Why
should we create even more programming languages?" with a simple answer: better
abstraction, better tools need time to be developed. And we can do better than
we currently are. Which is a nice sentiment that I deeply share, as a hobby/semi-serious
language designer.

* [Lambda: The Ultimate Declarative](http://repository.readscheme.org/ftp/papers/ai-lab-pubs/AIM-379.pdf) by **Guy Steele** (1976)

This paper is filled to the brim with interesting ideas. The symmetry of lambdas
and actors was especially surprising. Rewriting function calls to jumps is not
that new an optimization, apparently, which is also interesting to know; the bit
about implementing tail-recursion as `GOTO` going back to the PDP-1 puts shame to
every language that still does not implement proper tail recursion. And I should
try to play around with the CPS-converter given in Appendix A, that one was really
interesting.

* [Debunking the 'Expensive Procedure Call' Myth, or, Procedure Call Implementations Considered Harmful, or, Lambda: The Ultimate GOTO](http://repository.readscheme.org/ftp/papers/ai-lab-pubs/AIM-443.pdf) by **Guy Steele** (1977)

An interesting insight into programming in the 70s. Coming from today it is
pretty much impossible that one learns that using `GOTO` is good for your
programs, neither as an optimization (most modern compilers are better than
average Joe Programmer at understanding how to optimize the program anyway)
nor as a stylistic choice (most blindly obey Djikstra's quip about `GOTO`
being harmful without having read the actual article, in my experience).
Now, I personally still find that sometimes `GOTO` might be acceptable
(in error handling/cleanup cases, very sparingly, for instance), but
the issue that Steele and adressed in this paper is pretty much accounted
for by now. Maybe I am mistaken, and am in the wrong business, though.

* [Adding an LLVM Backend to Bigloo Scheme](https://gupea.ub.gu.se/bitstream/2077/34201/1/gupea_2077_34201_1.pdf) by **Mikael Brockman** (2013)

An interesting masters thesis on compiling Scheme—more specifically,
Bigloo Scheme—into LLVM. It is surprisingly short and spends very little
time actually talking about the specifics of the implementation, but
the authors approach seems interesting. I played around with a LLVM
backend for zepto that works on the textual IR level, but I did not find
a good way to make it modular and abandoned it after implementing a useless
subset of Scheme; this is to say this undertaking resonated with me.
I should take a look at the final product at some point.

* [SECD: Design Issues](http://prism.ucalgary.ca/bitstream/1880/46590/2/1989-369-31.pdf) by ? (?)

I cannot remember how I found this paper and a quick search for it
doesn't reveal much information, either. Its title seems to be "SECD:
Design Issues" and it seems to be a report on the work of a research
group at the University of Calgary (led by Graham and Birtwistle,
maybe?), probably in the late 80s or early 90s (89 at least, according
to the citations). It describes an effort to create a chip for the
SECD ~virtual~ machine. It is really interesting and I learned tons
reading it, especially because I have little idea of hardware design
and manufacturing.

* [Exceptional Continuations in JavaScript](http://www.schemeworkshop.org/2007/procPaper4.pdf) by **Florian Loitsch** (2007)

An interesting little paper on how to implement continuations in a
language that doesn't have them. It's a bit clumsy if you compare
it to first-class continuations, but this is more or less a given,
at least in my opinion. It also helps my understanding of how to
implement continuations, even if I have already implemented them
myself. If I ever need to do so again, I might look at it beforehand,
as the techniques described in the paper are interesting.

* [Scheme: An Interpreter for Extended Lambda Calculus](http://repository.readscheme.org/ftp/papers/ai-lab-pubs/AIM-349.pdf) by **Gerald Sussman and Guy Steele** (1975)

This paper blew my mind. I had no idea that the initial implementation
of Scheme had such a wonderful actor system. Sure it is a bit more
crude than what we are used to these days, but it is still much more
advanced than I would have expected. The same for the pattern-matching
implementation, which is wonderfully elegant and simple. I could reimplement
a simple pattern-matcher in zepto for a blog post maybe. In general the
code presented in the blog post is incredibly advanced, at least much more
than anything I would've thought is to be found in a paper from the mid-70's.

On another note, them basically implementing `Promise.race` and then calling
it useless is wonderfully ironic.

* [i, Poet: Automatic Chinese Poetry Composition through a Generative Summarization Framework under Constrained Optimization](http://homepages.inf.ed.ac.uk/mlap/Papers/IJCAI13-324-1.pdf) by **Rui Yan et al.** (2013)

I have had a lingering interest in AI for a long time, but decided never to
act on it, partly because it is not my domain of expertise and partly because
everyone seems to want to jump on that bandwagon with bad ideas lately. I still
read about it and think I have a pretty okay grasp on the concepts, I just never
had a project that required me to write a truly learning system. With that in mind,
this is still a very interesting paper, because it describes in great detail an
approach to AI writing poetry in a sensible way. It's a bit annoying that they did
not provide an example poem that was generated—I was really interested in seeing
one of those—, but I liked the idea of having multiple neural nets, one for writing
the draft and one for refining it. That felt similar to how I approach writing:
brainstorm and build, then make sense of the mess you've just created. I have always
been a poor editor, so maybe the second neural net would be of greater help for me,
but I assume it will be some time until I can tap into the potential of AI that
helps me convey what I want to write.

* [An Incremental Approach to Compiler Construction](https://github.com/namin/inc/blob/master/docs/paper.pdf) by **Abdulaziz Ghuloum** (2006)

I am not sure I agree with the methodology—and the implementation—provided in
this paper. It mgith be that the reader has implemented a compiler after they've
worked through the paper, but the compiler is really bad, the architecture does
not lend itself well to extension, and paedagogically the reader has not gained
as much as they would have with a better engineered, "do things the right way"
compiler. The compiler presented in there is a big messy hack and noone should
have to base their compiler on that.

* [The Security Impact of HTTPS Interception](https://jhalderm.com/pub/papers/interception-ndss17.pdf) by **Zakir Durumeric et al.** (2017)

This paper broke my heart. It is incredible that at this day and age people still
think HTTPS interception can increase security instead of severely decreasing it.
I don't think I have to say more on that matter. Almost 11% percent intercepted
traffic is damn scary.

* [Generational Garbage Collection and the Radioactive Decay Model](http://www.cesura17.net/~will/Professional/Research/Papers/radioactive.pdf) by **William Clinger** (1997)

The main take-away from this paper is that I am probably too thick to implement
a good garbage collector. Generational garbage collectors are relatively hard
to build properly—I've tried and failed before. Larceny is a truly interesting
Scheme implementation. I should try it out sometime, because I thoroughly enjoyed
reading papers about it—its documentation on its compiler passes are pretty
pristine.

* [BigchainDB: A Scalable Blockchain Database](https://www.bigchaindb.com/whitepaper/bigchaindb-whitepaper.pdf) by **Tren McConaghy** et al.

More blockchain bullshit. Yay. This incredibly badly written paper presents a
fundamentally flawed idea—basically a shitty framework to RethinkDB—a database
that's failed as well, and for good reasons. I know I sound like an ass here,
but I've lost patience with people who have no idea about how to build a database
building databases, because I am the one who cleans up after the mess when a
startup ends up choosing that tech and the DB ends up blowing up (mostly because
of configuration flaws, of course, but if your default configurations are
broken, your system likely is broken as well). Bottom line: I did not enjoy
reading this paper.

* [Generalized Parser Combinators](http://www.cs.uwm.edu/%7Edspiewak/papers/generalized-parser-combinators.pdf) by **Daniel Spiewak** (2010)

I actually tried to implement GLL parser combinators for zepto before and failed
at the trampolining, so this paper clarified a lot of things that I did not understand.
I wanted to try and implement a GLL again in the future and after reading this paper,
I feel equipped to tackle the problem. As an aside: Scala code still looks weird to me.
Kind of like I felt reading Haskell before I knew it.

* [Lambda: The Ultimate Imperative](http://repository.readscheme.org/ftp/papers/ai-lab-pubs/AIM-353.pdf) by **Gerald Sussman and Guy Steele** (1976)

I've read this paper before, and it is still wonderful. Scheme speaks to me in a
very peculiar way. But, instead of waxing poetic, I will just quote the end of
the paper, because there is a very deep insight for language designers to be
found here: "No amount of language design can *force* a programmer to write clear
programs. If the programmer's conception of the problem is badly organized, then
[their] program will also be badly organized. The extent to which a programming
language can help a programmer to organize [their] problem is precisely the extent
to which it provides features appropriate to [their] problem domain. The emphasis
should not be on eliminating "bad" language constructs, but on discovering or
inventing helpful ones."

* [The impact of syntax colouring on program comprehension](http://www.ppig.org/sites/default/files/2015-PPIG-26th-Sarkar.pdf) by **Advait Sarkar** (2015)

With a sample size of ten I feel like it would be a bit dubious for me to derive
general conclusion from this paper—especially considering three datasets had to be
excluded from part of the conclusions, reducing the sample size to seven. Nonetheless,
it is interesting research into how effective syntax highlighting really is, because
most of the arguments for or against syntax highlighting seem to be strawman arguments
or highly subjective (I won't link to blog posts that come to mind, because I'm not that
much of an ass). In toto, this paper is a valuable addition to the conversation about the
cost and gains of syntax highlighting.

* [Fast Deterministic Selection](https://arxiv.org/pdf/1606.00484.pdf) by **Andrei Alexandrescu**

I always liked Alexandrescu's talks. Sadly, I've not yet managed to
try out D, the programming language he is mostly working on except for
his work on C++. This paper presents a fun new algorithm for selection
in a field of research that has not seen great advances since Hoare's
seminal paper (except for Median of Medians, which builds on it). I
am looking forward to try it out in D and see how it performs. I might
also want to implement it in another language if it performs well.

* [The view from the left](http://strictlypositive.org/view-Dec6.ps.gz) by **Conor McBride & James McKinna** (2004)

I can't say I understood a lot of it, but I still feel like a learned
a lot, just struggling through it and looking up all kinds of things.
I respect Connor McBride a lot—I was not familiar with James McKinnas
work, but I am will be keeping an eye out from now on—and so that was
rewarding in itself already.

* [I am not a number: I am a free variable](http://strictlypositive.org/notanum.ps.gz) by **Conor McBride & James McKinna** (2004)

Another Epigram paper, but shorter and more approachable, because it
describes the implementation of a specfic feature (syntax manipulation).
It's probably also closer to my field of expertise and thus easier for
me to understand. I enjoyed this paper as well. That being said, their
insistence of putting an accent on role is a little irritating, because
I don't understand it—one of the reasons I don't like The New Yorker
articles sometimes. Also, I like how they talk about their users when
they say: “Our foes cannot choose wicked names in order to make mischief.”

* [Futexes Are Tricky](https://www.akkadia.org/drepper/futex.pdf) by **Ulrich Drepper** (2011)

Indeed they are. This paper is a very useful resource if one needs to
use futexes. It's not that great for light reading—at least not section
2, which goes into great detail to explain every input for the syscall.
It's useful, just not made for reading as prose. The whole paper is written
in a tutorial-style, and realitvely instructive. I enjoyed learning about
futexes, in any case.

* [Distributed Algorithm for Optimal Power Flow on a Radial Network](http://smart.caltech.edu/papers/distributedalg.pdf) by **Qiuyu Peng and Steven Low** (2014)

Coming from a field I've not had much exposure to, this paper is filled
with lingo I don't understand. It didn't prevent me from finding it
intriguing, though, and I think I actually learned something.

* [Optimal Decentralized Primary Frequency Control in Power Networks](http://smart.caltech.edu/papers/optimaldecent.pdf) by **Changhong Zhao and Steven Low** (2014)

This paper is from the same source as the one above, and so I had the
same trouble. Sadly this one also suffers from bad writing; I assume
the authors are not native English speakers. This was detrimental to
my reading experience, unfair as it is. I am unfamiliar with the
territory and the writing increased the cognitive load—not a great
combo.

* [Ornamental Algebras, Algebraic Ornaments](https://personal.cis.strath.ac.uk/conor.mcbride/pub/OAAO/LitOrn.pdf) by **Conor McBride** (2011)

Yet another paper by the infallible Conor McBride. This meditation on
data types and their relationship is based on a simple idea that blew
my mind completely: data types are but a kind of refinement types of
each other, joined by forgetful functions in the one direction and
information-adding functions in the other. Pretty darn clever.

* [Model, View, Controller](http://heim.ifi.uio.no/~trygver/1979/mvc-2/1979-12-MVC.pdf) by **Trygve M. H. Reenskaug** (1979)

Another one of those papers that was incredibly insightful and solved
a problem we still face today, very cleanly. It's incredibly short,
more of a personal note than a paper, but it cleanly sets boundaries
between components.

* [What Not to Do When Writing an Interpreter for Specialisation](https://www.cs.rice.edu/~taha/teaching/02F/511/papers/jonesWhatNot96.ps) by **Neil D. Jones** (1996)

Pretty dry but highly informative. This makes me want to write a toy
project that implements program specialization. I should probably reread
the paper when not jetlagged anymore.

* [OpenConflict: Preventing Real Time Map Hacks in Online Games](https://www.shiftleft.org/papers/openconflict/openconflict.pdf) by **Elie Bursztein et al.** (2011)

An impressive amount of engineering by the authors went into cracking
online games and then fixing them. Super fun to read and interesting, even
though my knowledge of elliptic curve cryptography is way too basic to
understand the protocol described in the later parts of the paper well.
It is written well enough to incentivize me to keep reading, though, so
all is well.

* [Symmetric Cryptography in Javascript](http://bitwiseshiftleft.github.io/sjcl/acsac.pdf) by **Emily Stark et al.** (2009)

Interesting read, even if it's a little outdated. I would love to see an
up-to-date version, especially because the benchmakrs where so browser-focused.
A lot has changed since 2009 in browser performance.

* [Why and how to use arbitrary precision](http://perso.ens-lyon.fr/philippe.theveny/cise.pdf) by **Kave R. Ghazi et al.** (2010)

This paper ties in to my lates project, a [reimplementation](https://github.com/hellerve/bc)
of bc. The constant folding part is especially interesting. I didn't
know about GCC's usagfe of mpfr in optimizations either and that section,
albeit short, was especially intriguing for that reason.

* [Designing extensible, domain-specific languages for mathematical diagrams](https://www.cs.cmu.edu/~kqy/resources/diagrams_obt.pdf) by **Katherine Ye et al.** (2017)

Super exciting idea! As a novice to most of the fields I read papers
from—I mean, how many domains can you have domain knowledge in, really?—,
having illustrations definitely helps a ton! Making this simpler, more accessible,
or just having better tooling should help tremenduously in incentivizing people
to build diagrams, which in turn incentivizes me to dive deeper into the field.

* [Visualizing LSTM decisions](https://arxiv.org/pdf/1705.08153v1.pdf) by **Jos van der Westhuizen & Joan Lasenby** (2017)

As always when it comes to papers outside of my limited domain of expertise
I cannot say I understood this paper thoroughly. This time, however, I feel
a little better, because someone with actual knowledge around the topic
presented on it at our ML paper reading group, which is nice.

After concurring that the paper was borderline unreadable, she explained
LSTMs, a very helpful addition. I feel equipped to talk about them more now.
The choice of illustrative examples in this papers was abominable.

* [Painterly Rendering for Animation](https://disney-animation.s3.amazonaws.com/uploads/production/publication_asset/47/asset/p477-meier_1996.pdf) by **Barbara J. Meier** (1996)

A beautiful paper, both in its writing—which is simple, not convoluted,
and does a great job at explaining everything—and its idea, which is
super simple: mixing particle rendering and painterly rendering of still
images. The particle rendering is necessary for continuity between frames,
and the idea seems obvious in hindsight, which is evidence for how powerful
it is.

* [Coherent Noise for Non-Photorealistic Rendering](http://graphics.pixar.com/library/NPRNoise/paper.pdf) by **Michael Kass & Davide Pesare** (2011)

Yet another nifty solution for the shower door effect, this time using coherent
noise. It seems to perform quite well and should be reasonably cheap, so I'm all
for it, though I cannot estimate whether it actually helps with anything.

* [Playing Atari with Deep Reinforcement Learning](https://arxiv.org/abs/1312.5602) by **Volodymyr Mnih** (2013)

Yet another paper from my paper reading group. It, too, was a bit painful to
read through, even though the topic seemed interesting at first. Of course, I
learned a lot about Reinforcement Learning in our session, but I don't think
the paper would've told me much—especially because the data in Reinforcement
Learning is often so different from the data in other flavors of ML. The
linear algebra didn't help, of course, although it wasn't _too_ bad.

* [Generating Pseudo-random Floating-Point Value](http://allendowney.com/research/rand/downey07randfloat.pdf) by **Allen B. Downey** (2007)

Extremely interesting algorithm, but I never really generated random floating
point values, so I cannot really say whether the algorithm is any good. It's
deeply satisfying to read anyway if you're into numerics.

* [Phyllotaxis](http://algorithmicbotany.org/papers/abop/abop-ch4.pdf) (Chapter 4 of “The Algorithmic Beauty of Plants”) by **Przemyslaw Prusinkiewicz && Aristid Lindenmayer** (1990)

This paper (or rather chapter) spawned a creative coding session, a few algorithmic
experiments, reflections on phyllotactic mechanism in the 2D layout of galaxies,
and an art print for my girlfriend, so I cannot complain.

### Books

* [You Can't Spell Trust without Rust](https://cdn.rawgit.com/Gankro/thesis/d2f0b64fe93c23923f3a43a7038427083edad4c5/thesis.pdf) by **Alexis Beingessner** (2015)

As one Reddit user helpfully put it: “You can't spell slaughter without laughter
either”. Technically this is not a book but a master's thesis, but I'll count
it as a book for reasons of vanity. It is relatively readable, but not very
exciting either. Rust excites me less and less the more I do with it, and this
thesis didn't help. I'll read a bit more about it, but for now I'll have to
conclude that Rust is not for me, neither theoretically nor practically.

## Recreational

### Papers
* [A Study of Prisoners and Guards in a Simulated Prison](http://www.zimbardo.com/downloads/1973%20A%20Study%20of%20Prisoners%20and%20Guards,%20Naval%20Research%20Reviews.pdf) by **Philip Zimbardo et al.** (1973)

One of the most famous papers of psychology. I had to read one
of Zimbardo's books when studying psychology at University, but
never got around to actually reading this infamous paper. It is
both well-written and topically interesting, but extremely disturbing.
I doubt any ethics committee would let an experiment like that
happen these days.

* [On Being Sane In Insane Places](https://isites.harvard.edu/fs/docs/icb.topic625827.files/On_Being_Sane_In_Insane_Places-1.pdf) by **David Rosenhan** (1973)

Another very interesting pyschological paper that I discovered
much too late. It is a paper in the same vein as the Zimbardo
paper above. Very clearly written, at times seeming unscientific,
but asking important questions and providing an excellent basis
for thinking about how psychiatry should work and how it does.
Of course, the situation described in this paper is not the
situation we are in right now (we have gone a long way since
the 70s after all), but we should be wary of the fact that back
then, too, we thought we did things the right way when in fact
we didn't.

* [High-Selectivity Electrochemical Conversion of CO2 to Ethanol using a Copper Nanoparticle/N-Doped Graphene Electrode](http://onlinelibrary.wiley.com/doi/10.1002/slct.201601169/full) by **Yang Song et al.** (2016)

Saying I understood this paper would be an overstatement. It was an
interesting read nonetheless and the research in it sounds promising.
To a clean future!

* [Can Additional Homeopathic Treatment Save Costs? A Retrospective Cost-Analysis Based on 44500 Insured Persons](http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0134657) by **Julia Ostermann et al.** (2015)

This study is a very important step towards a real cost evaluation
of homeopathy. While I would be careful not to generalize, because
the study had a lot of moving pats that are unaccounted for, the
sample size is pretty huge and the conclusions are pretty decisive
in that I can say that, no, homeopathic treatment is not generally
cheaper than traditional western medicine.

* [Caesarean sections and for-profit status of hospitals: systematic review and meta-analysis](http://bmjopen.bmj.com/content/bmjopen/7/2/e013670.full.pdf) by **Olir Hoxha et al.** (2017)

Somewhat unsettling research, but unsurprising—I am a cynic, after
all. It's also not necessarily bad a priori that more C sections are
performed, I guess, but it hints at an underlying profit-driven environment
in profit-driven hospitals (duh). This holds true regardless of patient
history, apparently, which, if generalizable (which I hope is not the case)
would be highly appalling.

* [Schrodinger’s Cat and World History: The Many Worlds Interpretation of Alternative Facts](https://arxiv.org/pdf/1703.10470.pdf) by **Tom Banks** (2017)

A highly entertaining read.

* [Tezos:  A Self-Amending Crypto-Ledger Position Paper](https://www.tezos.com/pdf/position_paper.pdf) by **L.M. Goodman** (2014)

I'm still pondering whether I should take part in the crowd sale.
But this sounds really cool.

* [On the Typography Of Flight-Deck Documentation](https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19930010781.pdf) by **Asaf Degani** (1992)

One of the most insightful looks into typography that I've found.
I don't anticipate I will be responsible for any flight-related
typography any time soon, but the advice given in this paper is
rock-solid.

* [Legible, are you sure? An experimentation-based typographical design in Safety-critical context](http://lii-enac.fr/articles/vinot-chi-2012.pdf) by **Jean-Luc Vinot & Sylvie Athènes** (2012)

Related to the item above, but a bit more analytical and focusing
on digital graphical interfaces instead of print. It's also not
as easy to infer simple rules from the paper, but it's still
presenting deep insights.

*False Suffocation Alarms, Spontaneous Panics, and Related Conditions—An Integrative Hypothesis* by **Donald F. Klein** (1992)

An interesting take on panic attacks, suffocation, and brain
signalling.

* [Tezos — A Self-Amending Crypto-Ledger White paper](https://www.tezos.com/pdf/white_paper.pdf) by **L.M. Goodman** (2014)

Still not convinced.

* [Deconstructing the evidence-based discourse in health sciences: truth, power and fascism](http://www.ucl.ac.uk/Pharmacology/dc-bits/holmes-deconstruction-ebhc-06.pdf) by **Dave Holmes et al.**

I thoroughly enjoyed this read, reading it as a joke.

### Books

* *Abhandlung über den Ursprung der Sprache* by **Johann Gottfried Herder** (1772)

This book was intriguing in multiple respects: way ahead of its time
and yet so much of it is reflecting the sentiments of its time, sometimes
in a painful manner, such as when Herder talks about Black people—or anyone
Non-white, for that matter. The first part is a bit hard to decypher, but
the second part is making up for it. If you want to take anything away
from this book, the last four pages actually summarize his main point
quite nicely (starting at the paragraph labeled `3.`).

* *Erzählte Zeit—50 deutsche Kurzgeschichten der Gegenwart* by **Manfred Durzak (Editor)** (1989)

A great collection of German short stories detailling life in Germany
during various periods of the 20th century. I don't think I can write
up a coherent comment about the book; there is just too much ground to
cover. I skipped two short stories that didn't appeal to me writing-wise,
but other than that I was very happy with the layout, sequencing, and the
stories themselves. I don't think there is a translation to any other
language of this particular book, but I'm sure most of the individual
stories are translated.

* *The Lover* by **Marguerite Duras** (1984)

Beautifully written story; it was the first book I read of Duras' and I definitely
missed out. I need to read the Hiroshima Mon Amour screenplay next, and I
think I would like to see the movie, although I'm typically not a fan of
movie adaptations if I really liked the book. We'll see.
